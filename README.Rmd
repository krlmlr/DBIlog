---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
pkgload::load_all()
```

# DBIlog

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/DBIlog)](https://cran.r-project.org/package=DBIlog)
<!-- badges: end -->

The goal of DBIlog is to implement logging for arbitrary DBI backends, similarly to Perl's [DBI::Log](https://metacpan.org/pod/DBI::Log).
This is useful for troubleshooting and auditing codes that access a database.
The initial use case for this package is to help debugging DBItest tests.

## Installation

You can install the released version of DBIlog from [CRAN](https://CRAN.R-project.org) with:

``` r
install.packages("DBIlog")
```

Install the development version from GitHub using

``` r
# install.packages("devtools")
devtools::install_github("r-dbi/DBIlog")
```


## Example

The `LoggingDBI` driver wraps arbitrary drivers:

```{r init}
library(DBIlog)
drv <- LoggingDBI(RSQLite::SQLite())
```

All calls to DBI methods are logged, by default to the console.
Logging can be redirected to a file, optionally all outputs may be logged as well.

```{r console}
conn <- dbConnect(drv, file = ":memory:")
dbWriteTable(conn, "iris", iris[1:3, ])
data <- dbGetQuery(conn, "SELECT * FROM iris")
dbDisconnect(conn)

data
```

The log is runnable R code!
Run it in a fresh session to repeat the operations, step by step or in an otherwise controlled fashion.
For example, use a collecting logger to output all calls and results after the fact.


```{r collect}
log_obj <- make_collect_log_obj()
collecting_logger <- logger(log_obj)

drv <- LoggingDBI(RSQLite::SQLite(), logger = collecting_logger)
conn <- dbConnect(drv, file = ":memory:")
dbWriteTable(conn, "iris", iris[1:3, ])
data <- dbGetQuery(conn, "SELECT * FROM iris")
dbDisconnect(conn)

log_obj$retrieve()

ev <- evaluate::evaluate(log_obj$retrieve())
cat(unlist(ev, use.names = FALSE), sep = "\n")
```

DBIlog is smart about DBI objects created or returned, and will assign a new variable name to each new object.
Cleared results or closed connections are not removed automatically.
Call `dbBegin()` and `dbCommit()` or `dbRollback()` (or `dbWithTransaction()`) on the driver object to define a scope for the autogenerated variable names.

```{r rollback, error = TRUE}
dbBegin(drv)

conn <- dbConnect(drv, file = ":memory:")
dbDisconnect(conn)

dbCommit(drv)

dbBegin(drv)

conn <- dbConnect(drv, file = ":memory:")
dbDisconnect(conn)

dbCommit(drv)
```
